<!doctype html>
<html lang="en" class="h-full">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Jaeger Constructor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/_sdk/element_sdk.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&amp;family=Teko:wght@500;700&amp;display=swap" rel="stylesheet">
  <style>
    body {
      box-sizing: border-box;
    }
    .font-orbitron { font-family: 'Orbitron', sans-serif; }
    .font-teko { font-family: 'Teko', sans-serif; }
    
    @keyframes neural-pulse {
      0%, 100% { box-shadow: 0 0 20px currentColor; opacity: 0.8; }
      50% { box-shadow: 0 0 40px currentColor; opacity: 1; }
    }
    
    .neural-pulse { animation: neural-pulse 2s infinite; }
    
    .part-slot {
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .part-slot::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0,200,255,0.3), transparent);
      transition: left 0.5s;
    }
    
    .part-slot:hover::before {
      left: 100%;
    }
    
    .combat-btn {
      transition: all 0.2s ease;
    }
    
    .combat-btn:hover:not(:disabled) {
      transform: scale(1.05);
    }
    
    .combat-btn:active:not(:disabled) {
      transform: scale(0.95);
    }
    
    .health-bar {
      transition: width 0.5s ease;
    }
    
    .position-display {
      font-family: 'Teko', sans-serif;
      font-size: 14px;
      color: #90e0ef;
      background: rgba(0,0,0,0.8);
      border: 1px solid rgba(0,180,216,0.3);
      padding: 8px 12px;
      border-radius: 6px;
      display: inline-block;
    }
  </style>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
 </head>
 <body class="h-full m-0 p-0 overflow-hidden">
  <div id="app" class="h-full w-full flex flex-col" style="background: linear-gradient(180deg, #000814 0%, #001d3d 50%, #003566 100%);"><!-- Header with Mode Toggle -->
   <div class="px-4 py-3" style="background: linear-gradient(90deg, rgba(0,180,216,0.2), rgba(0,119,182,0.2)); border-bottom: 3px solid rgba(0,180,216,0.5);">
    <div class="flex items-center justify-between max-w-7xl mx-auto">
     <div>
      <h1 id="game-title" class="font-orbitron text-xl md:text-3xl font-black" style="color: #00b4d8; text-shadow: 0 0 30px rgba(0,180,216,0.8);">‚öîÔ∏è JAEGER CONSTRUCTOR</h1>
      <p id="instruction-text" class="font-teko text-sm md:text-base" style="color: #90e0ef;">Build your mech ‚Ä¢ Move parts with arrows ‚Ä¢ Weld to attach!</p>
     </div>
     <div class="flex gap-2"><button id="build-mode-btn" class="combat-btn font-orbitron px-4 py-2 rounded-lg text-sm font-bold" style="background: linear-gradient(135deg, #00b4d8, #0077b6); color: #000814; border: 2px solid #00b4d8;"> <span id="build-mode-label">üîß BUILD</span> </button> <button id="combat-mode-btn" class="combat-btn font-orbitron px-4 py-2 rounded-lg text-sm font-bold" style="background: linear-gradient(135deg, #e63946, #d62828); color: #fff; border: 2px solid #e63946;"> <span id="combat-mode-label">‚öîÔ∏è COMBAT</span> </button>
     </div>
    </div>
   </div><!-- Main Game Area -->
   <div class="flex-1 flex flex-col lg:flex-row overflow-hidden"><!-- BUILD MODE -->
    <div id="build-mode" class="flex-1 flex flex-col lg:flex-row"><!-- Parts Inventory -->
     <div class="lg:w-72 p-4 overflow-y-auto" style="background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.4)); border-right: 2px solid rgba(0,180,216,0.3);">
      <h2 class="font-orbitron text-xl mb-4 neural-pulse" style="color: #00b4d8;">‚ö° JAEGER PARTS</h2>
      <div class="space-y-2" id="parts-inventory"><!-- Parts will be generated by JS -->
      </div>
      <div class="mt-6 p-4 rounded-lg" style="background: rgba(0,180,216,0.1); border: 2px solid rgba(0,180,216,0.3);">
       <div class="font-teko text-lg font-bold mb-2" style="color: #00b4d8;">
        üìä JAEGER STATS
       </div>
       <div class="space-y-2 font-teko text-base" style="color: #90e0ef;">
        <div class="flex justify-between"><span>POWER:</span> <span id="stat-power" class="font-bold">0</span>
        </div>
        <div class="flex justify-between"><span>ARMOR:</span> <span id="stat-armor" class="font-bold">0</span>
        </div>
        <div class="flex justify-between"><span>SPEED:</span> <span id="stat-speed" class="font-bold">0</span>
        </div>
        <div class="flex justify-between"><span>TOTAL:</span> <span id="stat-total" class="font-bold" style="color: #00b4d8;">0</span>
        </div>
       </div>
      </div>
     </div><!-- 3D Build Area -->
     <div class="flex-1 relative">
      <div id="build-canvas" class="w-full h-full"></div><!-- Build Controls -->
      <div class="absolute top-4 right-4 space-y-2">
       <div class="position-display">
        <div>
         Height: <span id="current-height" class="font-bold">0.0</span>m
        </div>
        <div>
         X Pos: <span id="current-x" class="font-bold">0.0</span>
        </div>
        <div>
         Z Pos: <span id="current-z" class="font-bold">0.0</span>
        </div>
       </div>
       <div class="grid grid-cols-3 gap-1">
        <div></div><button id="move-up-btn" class="combat-btn font-orbitron px-3 py-2 rounded text-xs font-bold" style="background: linear-gradient(135deg, #0077b6, #023e8a); color: #fff; border: 2px solid #0077b6;"> ‚ñ≤ </button>
        <div></div><button id="move-left-btn" class="combat-btn font-orbitron px-3 py-2 rounded text-xs font-bold" style="background: linear-gradient(135deg, #0077b6, #023e8a); color: #fff; border: 2px solid #0077b6;"> ‚óÑ </button> <button id="move-down-btn" class="combat-btn font-orbitron px-3 py-2 rounded text-xs font-bold" style="background: linear-gradient(135deg, #0077b6, #023e8a); color: #fff; border: 2px solid #0077b6;"> ‚ñº </button> <button id="move-right-btn" class="combat-btn font-orbitron px-3 py-2 rounded text-xs font-bold" style="background: linear-gradient(135deg, #0077b6, #023e8a); color: #fff; border: 2px solid #0077b6;"> ‚ñ∫ </button>
        <div></div><button id="move-forward-btn" class="combat-btn font-orbitron px-3 py-2 rounded text-xs font-bold" style="background: linear-gradient(135deg, #0077b6, #023e8a); color: #fff; border: 2px solid #0077b6;"> ‚Üë </button> <button id="move-back-btn" class="combat-btn font-orbitron px-3 py-2 rounded text-xs font-bold" style="background: linear-gradient(135deg, #0077b6, #023e8a); color: #fff; border: 2px solid #0077b6;"> ‚Üì </button>
       </div><button id="weld-btn" class="combat-btn w-full font-orbitron px-4 py-3 rounded-lg text-sm font-bold disabled:opacity-50" style="background: linear-gradient(135deg, #ffc300, #ffb700); color: #000814; border: 2px solid #ffd60a;"> ‚ö° WELD PART </button> <button id="clear-jaeger-btn" class="combat-btn w-full font-teko px-4 py-2 rounded-lg text-sm font-bold" style="background: linear-gradient(135deg, #6c757d, #495057); color: #fff; border: 2px solid #6c757d;"> üîÑ RESET ALL </button>
      </div><!-- Keyboard Hints -->
      <div class="absolute bottom-4 left-4" style="background: rgba(0,0,0,0.85); padding: 12px; border-radius: 8px; border: 2px solid rgba(0,180,216,0.4);">
       <div class="font-orbitron text-xs mb-2" style="color: #00b4d8;">
        ‚å®Ô∏è KEYBOARD CONTROLS
       </div>
       <div class="font-teko text-xs space-y-1" style="color: #90e0ef;">
        <div>
         ‚Üë‚Üì - Move Up/Down
        </div>
        <div>
         ‚Üê‚Üí - Move Left/Right
        </div>
        <div>
         W/S - Move Forward/Back
        </div>
        <div>
         SPACE - Weld Part
        </div>
       </div>
      </div>
     </div>
    </div><!-- COMBAT MODE -->
    <div id="combat-mode" class="flex-1 flex-col hidden">
     <div class="flex-1 relative">
      <div id="combat-canvas" class="w-full h-full"></div><!-- Combat HUD -->
      <div class="absolute top-0 left-0 right-0 p-4">
       <div class="max-w-4xl mx-auto grid grid-cols-2 gap-4"><!-- Player Health -->
        <div>
         <div class="font-orbitron text-sm mb-1" style="color: #00b4d8;">
          YOUR JAEGER
         </div>
         <div class="h-8 rounded-lg overflow-hidden" style="background: rgba(0,0,0,0.8); border: 2px solid rgba(0,180,216,0.5);">
          <div id="player-health-bar" class="health-bar h-full" style="width: 100%; background: linear-gradient(90deg, #00b4d8, #0077b6);"></div>
         </div>
         <div class="font-teko text-lg mt-1" style="color: #90e0ef;">
          HP: <span id="player-hp">100</span> / 100
         </div>
        </div><!-- Enemy Health -->
        <div>
         <div class="font-orbitron text-sm mb-1 text-right" style="color: #e63946;">
          KAIJU
         </div>
         <div class="h-8 rounded-lg overflow-hidden" style="background: rgba(0,0,0,0.8); border: 2px solid rgba(230,57,70,0.5);">
          <div id="enemy-health-bar" class="health-bar h-full" style="width: 100%; background: linear-gradient(90deg, #e63946, #d62828);"></div>
         </div>
         <div class="font-teko text-lg mt-1 text-right" style="color: #ff8fa3;">
          HP: <span id="enemy-hp">150</span> / 150
         </div>
        </div>
       </div>
      </div><!-- Combat Controls -->
      <div class="absolute bottom-4 left-0 right-0 p-4">
       <div class="max-w-4xl mx-auto">
        <div class="font-orbitron text-xs text-center mb-2" style="color: #90e0ef;">
         üéÆ CLICK to enable ‚Ä¢ WASD to move ‚Ä¢ MOUSE to look ‚Ä¢ LEFT CLICK sword ‚Ä¢ RIGHT CLICK plasma
        </div>
        <div class="grid grid-cols-3 gap-3"><button id="attack-punch-btn" class="combat-btn font-orbitron px-6 py-4 rounded-lg text-sm font-bold" style="background: linear-gradient(135deg, #fb5607, #ff006e); color: #fff; border: 2px solid #fb5607;"> üëä PUNCH [1]<br><span class="text-xs opacity-75">DMG: 15-25</span> </button> <button id="attack-plasma-btn" class="combat-btn font-orbitron px-6 py-4 rounded-lg text-sm font-bold" style="background: linear-gradient(135deg, #00b4d8, #0077b6); color: #fff; border: 2px solid #00b4d8;"> ‚ö° PLASMA [2]<br><span class="text-xs opacity-75">DMG: 20-35</span> </button> <button id="attack-sword-btn" class="combat-btn font-orbitron px-6 py-4 rounded-lg text-sm font-bold" style="background: linear-gradient(135deg, #ffc300, #ffb700); color: #000814; border: 2px solid #ffc300;"> ‚öîÔ∏è BLADE [3]<br><span class="text-xs opacity-75">DMG: 25-40</span> </button>
        </div>
       </div>
      </div><!-- Battle Log -->
      <div class="absolute top-32 left-4 w-80 max-h-48 overflow-y-auto p-3 rounded-lg" style="background: rgba(0,0,0,0.9); border: 2px solid rgba(0,180,216,0.3);">
       <div class="font-orbitron text-xs mb-2" style="color: #00b4d8;">
        ‚ö° NEURAL LINK LOG
       </div>
       <div id="battle-log" class="font-teko text-sm space-y-1" style="color: #90e0ef;">
        <div>
         System initialized...
        </div>
        <div>
         Neural handshake complete!
        </div>
        <div style="color: #ffc300;">
         Ready for combat!
        </div>
       </div>
      </div><!-- Victory/Defeat Screen -->
      <div id="battle-result" class="absolute inset-0 flex items-center justify-center hidden" style="background: rgba(0,0,0,0.95);">
       <div class="text-center">
        <div id="result-title" class="font-orbitron text-5xl font-black mb-4"></div>
        <div id="result-message" class="font-teko text-2xl mb-6" style="color: #90e0ef;"></div><button id="return-build-btn" class="combat-btn font-orbitron px-8 py-4 rounded-lg text-lg font-bold" style="background: linear-gradient(135deg, #00b4d8, #0077b6); color: #fff; border: 2px solid #00b4d8;"> üîß RETURN TO BUILD </button>
       </div>
      </div>
     </div>
    </div>
   </div>
  </div>
  <script>
    const defaultConfig = {
      game_title: '‚öîÔ∏è JAEGER CONSTRUCTOR',
      instruction_text: 'Build your mech ‚Ä¢ Move parts with arrows ‚Ä¢ Weld to attach!',
      build_mode_label: 'üîß BUILD',
      combat_mode_label: '‚öîÔ∏è COMBAT',
      background_color: '#000814',
      primary_color: '#00b4d8',
      secondary_color: '#90e0ef',
      enemy_color: '#e63946',
      accent_color: '#ffc300',
      font_family: 'Orbitron',
      font_size: 16
    };

    let config = { ...defaultConfig };
    let currentMode = 'build';
    let selectedPartType = null;
    let tempPart = null;
    let currentHeight = 0;
    let currentX = 0;
    let currentZ = 0;
    let weldedParts = [];
    let jaegerStats = { power: 0, armor: 0, speed: 0 };
    let playerHP = 100;
    let enemyHP = 150;
    let battleLog = [];
    let combatInProgress = false;
    let keys = {};
    let playerPosition = { x: -8, z: 0 };
    let playerRotation = 0;
    let buildScene, buildCamera, buildRenderer;
    let combatScene, combatCamera, combatRenderer;
    let playerJaeger, enemyKaiju;

    const partTypes = [
      { id: 'legs', name: 'LEGS', emoji: 'ü¶ø', color: 0x00b4d8, power: 15, armor: 25, speed: 10, height: 0 },
      { id: 'lower-body', name: 'LOWER BODY', emoji: 'üî©', color: 0x0077b6, power: 20, armor: 30, speed: 5, height: 2 },
      { id: 'core', name: 'REACTOR CORE', emoji: '‚ö°', color: 0xffc300, power: 40, armor: 20, speed: 10, height: 4 },
      { id: 'upper-body', name: 'UPPER BODY', emoji: 'üõ°Ô∏è', color: 0x023e8a, power: 25, armor: 35, speed: 5, height: 6 },
      { id: 'arms', name: 'ARMS', emoji: 'üí™', color: 0x0096c7, power: 30, armor: 15, speed: 15, height: 6.5 },
      { id: 'head', name: 'HEAD', emoji: 'ü§ñ', color: 0x48cae4, power: 20, armor: 20, speed: 20, height: 8.5 },
      { id: 'weapon-l', name: 'LEFT WEAPON', emoji: '‚öîÔ∏è', color: 0xe63946, power: 35, armor: 10, speed: 10, height: 7 },
      { id: 'weapon-r', name: 'RIGHT WEAPON', emoji: 'üî´', color: 0xd62828, power: 35, armor: 10, speed: 10, height: 7 }
    ];

    function initBuildMode() {
      const container = document.getElementById('build-canvas');
      buildScene = new THREE.Scene();
      buildScene.background = new THREE.Color(0x000814);
      buildScene.fog = new THREE.Fog(0x000814, 10, 50);
      buildCamera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
      buildCamera.position.set(8, 6, 12);
      buildCamera.lookAt(0, 4, 0);
      buildRenderer = new THREE.WebGLRenderer({ antialias: true });
      buildRenderer.setSize(container.clientWidth, container.clientHeight);
      buildRenderer.shadowMap.enabled = true;
      buildRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
      container.appendChild(buildRenderer.domElement);
      
      const ambientLight = new THREE.AmbientLight(0x404060, 0.5);
      buildScene.add(ambientLight);
      const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
      mainLight.position.set(10, 15, 10);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      buildScene.add(mainLight);
      const blueLight = new THREE.PointLight(0x00b4d8, 1.5, 30);
      blueLight.position.set(-5, 5, 5);
      buildScene.add(blueLight);
      const orangeLight = new THREE.PointLight(0xffc300, 1.2, 25);
      orangeLight.position.set(5, 3, -5);
      buildScene.add(orangeLight);
      const rimLight = new THREE.DirectionalLight(0x48cae4, 0.6);
      rimLight.position.set(-10, 5, -10);
      buildScene.add(rimLight);
      const gridHelper = new THREE.GridHelper(30, 30, 0x00b4d8, 0x003566);
      buildScene.add(gridHelper);
      const platformGeom = new THREE.CylinderGeometry(6, 6, 0.3, 32);
      const platformMat = new THREE.MeshStandardMaterial({ 
        color: 0x023e8a,
        metalness: 0.9,
        roughness: 0.2,
        emissive: 0x00b4d8,
        emissiveIntensity: 0.15
      });
      const platform = new THREE.Mesh(platformGeom, platformMat);
      platform.receiveShadow = true;
      buildScene.add(platform);
      animateBuild();
    }

    let mouseX = 0;
    let mouseY = 0;
    let cameraYaw = 0;
    let cameraPitch = 0;

    function initCombatMode() {
      const container = document.getElementById('combat-canvas');
      combatScene = new THREE.Scene();
      combatScene.background = new THREE.Color(0x001d3d);
      combatScene.fog = new THREE.Fog(0x001d3d, 15, 60);
      combatCamera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
      combatCamera.position.set(-8, 6, 5);
      combatRenderer = new THREE.WebGLRenderer({ antialias: true });
      combatRenderer.setSize(container.clientWidth, container.clientHeight);
      combatRenderer.shadowMap.enabled = true;
      container.appendChild(combatRenderer.domElement);
      
      // Pointer lock for mouse control
      container.addEventListener('click', () => {
        if (currentMode === 'combat' && combatInProgress) {
          container.requestPointerLock();
        }
      });
      
      document.addEventListener('pointerlockchange', () => {
        if (document.pointerLockElement === container) {
          addBattleLog('üéÆ Mouse controls active!', '#00b4d8');
        }
      });
      
      document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === container) {
          mouseX = e.movementX || 0;
          mouseY = e.movementY || 0;
          cameraYaw -= mouseX * 0.002;
          cameraPitch -= mouseY * 0.002;
          cameraPitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraPitch));
        }
      });
      
      container.appendChild(combatRenderer.domElement);
      
      const ambientLight = new THREE.AmbientLight(0x202040, 0.3);
      combatScene.add(ambientLight);
      const spotLight = new THREE.SpotLight(0xffffff, 1.5);
      spotLight.position.set(0, 20, 0);
      spotLight.castShadow = true;
      combatScene.add(spotLight);
      const redLight = new THREE.PointLight(0xe63946, 1.2, 30);
      redLight.position.set(10, 5, 0);
      combatScene.add(redLight);
      const blueLight = new THREE.PointLight(0x00b4d8, 1.2, 30);
      blueLight.position.set(-10, 5, 0);
      combatScene.add(blueLight);
      const floorGeom = new THREE.PlaneGeometry(50, 50);
      const floorMat = new THREE.MeshStandardMaterial({ 
        color: 0x001d3d,
        metalness: 0.6,
        roughness: 0.8
      });
      const floor = new THREE.Mesh(floorGeom, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      combatScene.add(floor);
      animateCombat();
    }

    function createPart3D(partType) {
      const part = partTypes.find(p => p.id === partType);
      if (!part) return null;
      
      // Ultra-realistic materials
      const battleSteelMat = new THREE.MeshStandardMaterial({
        color: part.color,
        metalness: 0.98,
        roughness: 0.15,
        emissive: part.color,
        emissiveIntensity: 0.2
      });
      
      const carbonFiberMat = new THREE.MeshStandardMaterial({
        color: 0x0a0a0a,
        metalness: 0.75,
        roughness: 0.35
      });
      
      const titaniumMat = new THREE.MeshStandardMaterial({
        color: 0x3c3c4e,
        metalness: 0.95,
        roughness: 0.25
      });
      
      const glowCoreMat = new THREE.MeshStandardMaterial({
        color: part.color,
        emissive: part.color,
        emissiveIntensity: 1.2,
        metalness: 0.7,
        roughness: 0.15
      });
      
      let mesh;
      
      switch(partType) {
        case 'legs':
          const legGroup = new THREE.Group();
          
          // Hip assembly - wider and more angular
          const hipGeom = new THREE.BoxGeometry(3.2, 0.8, 1.6);
          const hip = new THREE.Mesh(hipGeom, battleSteelMat);
          hip.position.y = 0.8;
          legGroup.add(hip);
          
          // Hip armor plates
          const hipPlateGeom = new THREE.BoxGeometry(3.4, 0.3, 1.8);
          const hipPlate = new THREE.Mesh(hipPlateGeom, titaniumMat);
          hipPlate.position.y = 1.05;
          legGroup.add(hipPlate);
          
          // Left and right legs - Striker Eureka style
          for (let side = -1; side <= 1; side += 2) {
            const xPos = side * 1.0;
            
            // Upper thigh joint
            const upperJointGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.4, 8);
            const upperJoint = new THREE.Mesh(upperJointGeom, glowCoreMat);
            upperJoint.position.set(xPos, 0.4, 0);
            legGroup.add(upperJoint);
            
            // Thigh - angular hexagonal prism
            const thighGeom = new THREE.CylinderGeometry(0.48, 0.45, 0.9, 6);
            const thigh = new THREE.Mesh(thighGeom, battleSteelMat);
            thigh.position.set(xPos, 0, 0);
            thigh.rotation.y = Math.PI / 6;
            legGroup.add(thigh);
            
            // Thigh armor plates - multiple angular pieces
            const frontPlateGeom = new THREE.BoxGeometry(0.7, 1.0, 0.25);
            const frontPlate = new THREE.Mesh(frontPlateGeom, titaniumMat);
            frontPlate.position.set(xPos, 0, 0.4);
            frontPlate.rotation.x = -0.1;
            legGroup.add(frontPlate);
            
            const sidePlateGeom = new THREE.BoxGeometry(0.3, 1.0, 0.6);
            const sidePlate = new THREE.Mesh(sidePlateGeom, carbonFiberMat);
            sidePlate.position.set(xPos + (side * 0.45), 0, 0);
            legGroup.add(sidePlate);
            
            // Knee joint - octagonal for more faces
            const kneeGeom = new THREE.CylinderGeometry(0.38, 0.38, 0.5, 8);
            const knee = new THREE.Mesh(kneeGeom, glowCoreMat);
            knee.position.set(xPos, -0.55, 0);
            knee.rotation.z = Math.PI / 2;
            legGroup.add(knee);
            
            // Knee cap armor
            const kneeCapGeom = new THREE.SphereGeometry(0.35, 8, 8, 0, Math.PI);
            const kneeCap = new THREE.Mesh(kneeCapGeom, titaniumMat);
            kneeCap.position.set(xPos, -0.55, 0.3);
            kneeCap.rotation.x = Math.PI / 2;
            legGroup.add(kneeCap);
            
            // Shin - hexagonal with taper
            const shinGeom = new THREE.CylinderGeometry(0.45, 0.4, 1.2, 6);
            const shin = new THREE.Mesh(shinGeom, battleSteelMat);
            shin.position.set(xPos, -1.3, 0);
            shin.rotation.y = Math.PI / 6;
            legGroup.add(shin);
            
            // Shin front armor - angled plate
            const shinArmorGeom = new THREE.BoxGeometry(0.65, 1.3, 0.2);
            const shinArmor = new THREE.Mesh(shinArmorGeom, carbonFiberMat);
            shinArmor.position.set(xPos, -1.3, 0.38);
            shinArmor.rotation.x = -0.15;
            legGroup.add(shinArmor);
            
            // Shin side plates
            for (let angle = 0; angle < 2; angle++) {
              const sideAngle = (angle === 0 ? 1 : -1) * side;
              const shinSideGeom = new THREE.BoxGeometry(0.25, 1.25, 0.55);
              const shinSide = new THREE.Mesh(shinSideGeom, titaniumMat);
              shinSide.position.set(xPos + (sideAngle * 0.35), -1.3, 0);
              legGroup.add(shinSide);
            }
            
            // Ankle joint - octagonal
            const ankleGeom = new THREE.CylinderGeometry(0.3, 0.3, 0.35, 8);
            const ankle = new THREE.Mesh(ankleGeom, glowCoreMat);
            ankle.position.set(xPos, -1.95, 0);
            ankle.rotation.z = Math.PI / 2;
            legGroup.add(ankle);
            
            // Foot - angular and geometric like Striker Eureka
            const footMainGeom = new THREE.BoxGeometry(0.75, 0.3, 1.3);
            const footMain = new THREE.Mesh(footMainGeom, battleSteelMat);
            footMain.position.set(xPos, -2.15, 0.35);
            legGroup.add(footMain);
            
            // Toe section - angled
            const toeGeom = new THREE.BoxGeometry(0.7, 0.25, 0.5);
            const toe = new THREE.Mesh(toeGeom, titaniumMat);
            toe.position.set(xPos, -2.2, 0.85);
            toe.rotation.x = -0.2;
            legGroup.add(toe);
            
            // Heel block
            const heelGeom = new THREE.BoxGeometry(0.7, 0.45, 0.5);
            const heel = new THREE.Mesh(heelGeom, battleSteelMat);
            heel.position.set(xPos, -2.15, -0.2);
            legGroup.add(heel);
            
            // Heel stabilizer
            const stabilizerGeom = new THREE.BoxGeometry(0.8, 0.2, 0.35);
            const stabilizer = new THREE.Mesh(stabilizerGeom, carbonFiberMat);
            stabilizer.position.set(xPos, -2.4, -0.25);
            legGroup.add(stabilizer);
            
            // Hydraulic pistons - 3 per leg
            for (let i = 0; i < 3; i++) {
              const yTop = 0.3 - (i * 0.3);
              const yBottom = -0.5 - (i * 0.35);
              const zOffset = -0.25 + (i * 0.15);
              
              const pistonGeom = new THREE.CylinderGeometry(0.08, 0.08, 
                Math.sqrt(Math.pow(yTop - yBottom, 2) + Math.pow(zOffset * 2, 2)), 8);
              const piston = new THREE.Mesh(pistonGeom, glowCoreMat);
              piston.position.set(xPos - (side * 0.3), (yTop + yBottom) / 2, zOffset);
              const angle = Math.atan2(yTop - yBottom, zOffset);
              piston.rotation.x = angle;
              legGroup.add(piston);
            }
            
            // Armor bolts details
            for (let i = 0; i < 8; i++) {
              const boltGeom = new THREE.CylinderGeometry(0.06, 0.06, 0.1, 6);
              const bolt = new THREE.Mesh(boltGeom, titaniumMat);
              bolt.position.set(xPos, -0.3 - (i * 0.25), 0.45);
              bolt.rotation.x = Math.PI / 2;
              legGroup.add(bolt);
            }
          }
          
          mesh = legGroup;
          break;
          
        case 'lower-body':
          const lowerGroup = new THREE.Group();
          
          // Pelvis
          const pelvisGeom = new THREE.BoxGeometry(2.8, 1.3, 1.6);
          const pelvis = new THREE.Mesh(pelvisGeom, battleSteelMat);
          lowerGroup.add(pelvis);
          
          // Side armor
          for (let side = -1; side <= 1; side += 2) {
            const sideArmorGeom = new THREE.BoxGeometry(0.3, 1.1, 1.5);
            const sideArmor = new THREE.Mesh(sideArmorGeom, titaniumMat);
            sideArmor.position.set(side * 1.55, 0, 0);
            lowerGroup.add(sideArmor);
          }
          
          // Belt
          const beltGeom = new THREE.BoxGeometry(2.9, 0.4, 0.3);
          const belt = new THREE.Mesh(beltGeom, carbonFiberMat);
          belt.position.set(0, 0.5, 0.85);
          lowerGroup.add(belt);
          
          mesh = lowerGroup;
          break;
          
        case 'core':
          const coreGroup = new THREE.Group();
          
          // Reactor core
          const reactorGeom = new THREE.SphereGeometry(0.9, 32, 32);
          const reactor = new THREE.Mesh(reactorGeom, glowCoreMat);
          coreGroup.add(reactor);
          
          // Inner glow
          const innerGeom = new THREE.SphereGeometry(0.7, 24, 24);
          const innerMat = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffff00,
            emissiveIntensity: 1.5,
            transparent: true,
            opacity: 0.8
          });
          const inner = new THREE.Mesh(innerGeom, innerMat);
          coreGroup.add(inner);
          
          // Energy rings
          for (let i = 0; i < 5; i++) {
            const ringGeom = new THREE.TorusGeometry(0.95 + i * 0.12, 0.04, 12, 32);
            const ring = new THREE.Mesh(ringGeom, titaniumMat);
            ring.rotation.x = Math.PI / 2;
            ring.rotation.z = (i * Math.PI) / 5;
            coreGroup.add(ring);
          }
          
          // Conduits
          for (let i = 0; i < 8; i++) {
            const angle = (i * Math.PI * 2) / 8;
            const conduitGeom = new THREE.CylinderGeometry(0.08, 0.08, 1.2, 12);
            const conduit = new THREE.Mesh(conduitGeom, glowCoreMat);
            conduit.position.x = Math.cos(angle) * 0.9;
            conduit.position.z = Math.sin(angle) * 0.9;
            conduit.rotation.z = Math.PI / 2;
            conduit.rotation.y = angle;
            coreGroup.add(conduit);
          }
          
          mesh = coreGroup;
          break;
          
        case 'upper-body':
          const upperGroup = new THREE.Group();
          
          // Chest plate
          const chestGeom = new THREE.BoxGeometry(3.0, 1.4, 1.9);
          const chest = new THREE.Mesh(chestGeom, battleSteelMat);
          chest.position.y = 0.2;
          upperGroup.add(chest);
          
          // Front armor
          const frontArmorGeom = new THREE.BoxGeometry(2.8, 1.2, 0.3);
          const frontArmor = new THREE.Mesh(frontArmorGeom, titaniumMat);
          frontArmor.position.set(0, 0.3, 1.0);
          upperGroup.add(frontArmor);
          
          // Shoulders
          const shoulderGeom = new THREE.BoxGeometry(3.8, 0.6, 1.6);
          const shoulder = new THREE.Mesh(shoulderGeom, carbonFiberMat);
          shoulder.position.y = 0.85;
          upperGroup.add(shoulder);
          
          // Shoulder caps
          for (let side = -1; side <= 1; side += 2) {
            const capGeom = new THREE.SphereGeometry(0.5, 20, 20, 0, Math.PI);
            const cap = new THREE.Mesh(capGeom, battleSteelMat);
            cap.position.set(side * 1.7, 0.85, 0);
            cap.rotation.z = side * Math.PI / 2;
            upperGroup.add(cap);
          }
          
          // Chest vents
          for (let i = -2; i <= 2; i++) {
            const ventGeom = new THREE.BoxGeometry(0.2, 0.85, 0.08);
            const vent = new THREE.Mesh(ventGeom, glowCoreMat);
            vent.position.set(i * 0.4, 0.2, 1.05);
            upperGroup.add(vent);
          }
          
          mesh = upperGroup;
          break;
          
        case 'arms':
          const armGroup = new THREE.Group();
          
          for (let side = -1; side <= 1; side += 2) {
            const xBase = side * 2.1;
            
            // Shoulder joint
            const shoulderGeom = new THREE.SphereGeometry(0.45, 24, 24);
            const shoulder = new THREE.Mesh(shoulderGeom, glowCoreMat);
            shoulder.position.set(xBase, 0, 0);
            armGroup.add(shoulder);
            
            // Upper arm
            const upperArmGeom = new THREE.CylinderGeometry(0.38, 0.35, 1.6, 16);
            const upperArm = new THREE.Mesh(upperArmGeom, battleSteelMat);
            upperArm.position.set(xBase + side * 0.35, -0.75, 0);
            upperArm.rotation.z = side * Math.PI / 6;
            armGroup.add(upperArm);
            
            // Elbow
            const elbowGeom = new THREE.SphereGeometry(0.28, 20, 20);
            const elbow = new THREE.Mesh(elbowGeom, glowCoreMat);
            elbow.position.set(xBase + side * 0.9, -1.6, 0);
            armGroup.add(elbow);
            
            // Forearm
            const forearmGeom = new THREE.CylinderGeometry(0.35, 0.38, 1.5, 16);
            const forearm = new THREE.Mesh(forearmGeom, battleSteelMat);
            forearm.position.set(xBase + side * 1.4, -2.35, 0);
            forearm.rotation.z = side * Math.PI / 8;
            armGroup.add(forearm);
            
            // Wrist
            const wristGeom = new THREE.CylinderGeometry(0.25, 0.25, 0.3, 16);
            const wrist = new THREE.Mesh(wristGeom, titaniumMat);
            wrist.position.set(xBase + side * 1.75, -3.1, 0);
            wrist.rotation.z = Math.PI / 2;
            armGroup.add(wrist);
            
            // Hand/Fist
            const palmGeom = new THREE.BoxGeometry(0.45, 0.55, 0.55);
            const palm = new THREE.Mesh(palmGeom, battleSteelMat);
            palm.position.set(xBase + side * 1.75, -3.45, 0);
            armGroup.add(palm);
            
            const knuckleGeom = new THREE.BoxGeometry(0.5, 0.25, 0.6);
            const knuckle = new THREE.Mesh(knuckleGeom, titaniumMat);
            knuckle.position.set(xBase + side * 1.75, -3.65, 0);
            armGroup.add(knuckle);
          }
          
          mesh = armGroup;
          break;
          
        case 'head':
          const headGroup = new THREE.Group();
          
          // Helmet
          const helmetGeom = new THREE.BoxGeometry(1.3, 1.1, 1.3);
          const helmet = new THREE.Mesh(helmetGeom, battleSteelMat);
          helmet.position.y = 0.25;
          headGroup.add(helmet);
          
          // Faceplate
          const faceplateGeom = new THREE.BoxGeometry(1.2, 0.9, 0.25);
          const faceplate = new THREE.Mesh(faceplateGeom, carbonFiberMat);
          faceplate.position.set(0, 0.3, 0.65);
          headGroup.add(faceplate);
          
          // Visor
          const visorGeom = new THREE.BoxGeometry(1.15, 0.45, 0.15);
          const visorMat = new THREE.MeshStandardMaterial({
            color: 0x00ffff,
            emissive: 0x00ffff,
            emissiveIntensity: 1.5,
            metalness: 0.98,
            roughness: 0.02,
            transparent: true,
            opacity: 0.95
          });
          const visor = new THREE.Mesh(visorGeom, visorMat);
          visor.position.set(0, 0.35, 0.72);
          headGroup.add(visor);
          
          // Jaw guard
          const jawGeom = new THREE.BoxGeometry(1.0, 0.4, 0.9);
          const jaw = new THREE.Mesh(jawGeom, titaniumMat);
          jaw.position.set(0, -0.1, 0.4);
          headGroup.add(jaw);
          
          // Side armor
          for (let side = -1; side <= 1; side += 2) {
            const sideGeom = new THREE.BoxGeometry(0.25, 0.9, 1.2);
            const sidePanel = new THREE.Mesh(sideGeom, carbonFiberMat);
            sidePanel.position.set(side * 0.65, 0.25, 0);
            headGroup.add(sidePanel);
          }
          
          // Antenna
          const antennaGeom = new THREE.CylinderGeometry(0.04, 0.08, 0.6, 12);
          const antenna = new THREE.Mesh(antennaGeom, glowCoreMat);
          antenna.position.y = 1.1;
          headGroup.add(antenna);
          
          mesh = headGroup;
          break;
          
        case 'weapon-l':
          const weaponLGroup = new THREE.Group();
          
          // Plasma cannon base
          const baseGeom = new THREE.CylinderGeometry(0.4, 0.45, 0.9, 16);
          const base = new THREE.Mesh(baseGeom, battleSteelMat);
          base.position.y = 0.1;
          weaponLGroup.add(base);
          
          // Power core
          const coreGeom = new THREE.SphereGeometry(0.35, 24, 24);
          const core = new THREE.Mesh(coreGeom, glowCoreMat);
          core.position.y = 0.1;
          weaponLGroup.add(core);
          
          // Barrel
          const barrelGeom = new THREE.CylinderGeometry(0.32, 0.32, 1.3, 16);
          const barrel = new THREE.Mesh(barrelGeom, titaniumMat);
          barrel.position.y = 0.85;
          weaponLGroup.add(barrel);
          
          // Inner barrel glow
          const innerBarrelGeom = new THREE.CylinderGeometry(0.25, 0.25, 1.35, 16);
          const innerBarrel = new THREE.Mesh(innerBarrelGeom, glowCoreMat);
          innerBarrel.position.y = 0.85;
          weaponLGroup.add(innerBarrel);
          
          // Cooling fins
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI * 2) / 6;
            const finGeom = new THREE.BoxGeometry(0.1, 1.2, 0.2);
            const fin = new THREE.Mesh(finGeom, carbonFiberMat);
            fin.position.set(Math.cos(angle) * 0.35, 0.85, Math.sin(angle) * 0.35);
            fin.rotation.y = angle;
            weaponLGroup.add(fin);
          }
          
          // Muzzle
          const muzzleGeom = new THREE.CylinderGeometry(0.28, 0.35, 0.4, 16);
          const muzzle = new THREE.Mesh(muzzleGeom, battleSteelMat);
          muzzle.position.y = 1.6;
          weaponLGroup.add(muzzle);
          
          mesh = weaponLGroup;
          break;
          
        case 'weapon-r':
          const weaponRGroup = new THREE.Group();
          
          // Chain sword grip
          const gripGeom = new THREE.CylinderGeometry(0.16, 0.16, 0.9, 16);
          const grip = new THREE.Mesh(gripGeom, carbonFiberMat);
          grip.position.y = -0.5;
          weaponRGroup.add(grip);
          
          // Pommel
          const pommelGeom = new THREE.SphereGeometry(0.2, 16, 16);
          const pommel = new THREE.Mesh(pommelGeom, titaniumMat);
          pommel.position.y = -0.95;
          weaponRGroup.add(pommel);
          
          // Guard
          const guardGeom = new THREE.BoxGeometry(0.8, 0.15, 0.25);
          const guard = new THREE.Mesh(guardGeom, battleSteelMat);
          guard.position.y = -0.05;
          weaponRGroup.add(guard);
          
          // Blade
          const bladeGeom = new THREE.BoxGeometry(0.28, 1.3, 0.12);
          const blade = new THREE.Mesh(bladeGeom, titaniumMat);
          blade.position.y = 0.85;
          weaponRGroup.add(blade);
          
          // Blade edge glow
          const edgeGeom = new THREE.BoxGeometry(0.22, 1.35, 0.08);
          const edge = new THREE.Mesh(edgeGeom, glowCoreMat);
          edge.position.y = 0.85;
          weaponRGroup.add(edge);
          
          // Chain teeth
          for (let i = 0; i < 12; i++) {
            const toothGeom = new THREE.BoxGeometry(0.25, 0.08, 0.04);
            const tooth = new THREE.Mesh(toothGeom, carbonFiberMat);
            tooth.position.set(-0.15, 0.25 + i * 0.1, 0);
            weaponRGroup.add(tooth);
            
            const toothR = new THREE.Mesh(toothGeom, carbonFiberMat);
            toothR.position.set(0.15, 0.25 + i * 0.1, 0);
            weaponRGroup.add(toothR);
          }
          
          // Tip
          const tipGeom = new THREE.ConeGeometry(0.16, 0.35, 4);
          const tip = new THREE.Mesh(tipGeom, glowCoreMat);
          tip.position.y = 1.65;
          weaponRGroup.add(tip);
          
          mesh = weaponRGroup;
          break;
          
        default:
          const defaultGeom = new THREE.BoxGeometry(1, 1, 1);
          mesh = new THREE.Mesh(defaultGeom, battleSteelMat);
      }
      
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.traverse((child) => {
        if (child.isMesh) {
          child.castShadow = true;
          child.receiveShadow = true;
        }
      });
      mesh.userData.partType = partType;
      mesh.userData.stats = { power: part.power, armor: part.armor, speed: part.speed };
      
      return mesh;
    }

    function createJaegerFromParts() {
      const jaegerGroup = new THREE.Group();
      
      // Organize parts by type for articulated movement
      jaegerGroup.userData.legs = null;
      jaegerGroup.userData.lowerBody = null;
      jaegerGroup.userData.core = null;
      jaegerGroup.userData.upperBody = null;
      jaegerGroup.userData.arms = null;
      jaegerGroup.userData.head = null;
      jaegerGroup.userData.weaponL = null;
      jaegerGroup.userData.weaponR = null;
      
      weldedParts.forEach(part => {
        const partMesh = part.clone();
        const partType = partMesh.userData.partType;
        
        // Store references to each body part
        if (partType === 'legs') jaegerGroup.userData.legs = partMesh;
        else if (partType === 'lower-body') jaegerGroup.userData.lowerBody = partMesh;
        else if (partType === 'core') jaegerGroup.userData.core = partMesh;
        else if (partType === 'upper-body') jaegerGroup.userData.upperBody = partMesh;
        else if (partType === 'arms') jaegerGroup.userData.arms = partMesh;
        else if (partType === 'head') jaegerGroup.userData.head = partMesh;
        else if (partType === 'weapon-l') jaegerGroup.userData.weaponL = partMesh;
        else if (partType === 'weapon-r') jaegerGroup.userData.weaponR = partMesh;
        
        jaegerGroup.add(partMesh);
      });
      
      jaegerGroup.position.set(-8, 0, 0);
      jaegerGroup.scale.set(1.2, 1.2, 1.2);
      
      // Initialize animation state
      jaegerGroup.userData.walkCycle = 0;
      jaegerGroup.userData.isAttacking = false;
      jaegerGroup.userData.attackFrame = 0;
      jaegerGroup.userData.currentAttack = null;
      
      return jaegerGroup;
    }

    function createKaiju() {
      const kaijuGroup = new THREE.Group();
      
      const kaijuMat = new THREE.MeshStandardMaterial({
        color: 0x1a0a1f,
        metalness: 0.2,
        roughness: 0.9,
        emissive: 0xe63946,
        emissiveIntensity: 0.4
      });
      
      const scaleMat = new THREE.MeshStandardMaterial({
        color: 0x4a1f4f,
        metalness: 0.4,
        roughness: 0.7
      });
      
      // Massive torso
      const torsoGeom = new THREE.BoxGeometry(5, 6, 3.5);
      const torso = new THREE.Mesh(torsoGeom, kaijuMat);
      torso.position.y = 4;
      torso.castShadow = true;
      kaijuGroup.add(torso);
      
      // Spine ridges
      for (let i = 0; i < 8; i++) {
        const spineGeom = new THREE.ConeGeometry(0.4, 1.2, 4);
        const spine = new THREE.Mesh(spineGeom, scaleMat);
        spine.position.set(0, 1.5 + i * 0.7, -1.5);
        spine.rotation.x = Math.PI / 6;
        kaijuGroup.add(spine);
      }
      
      // Huge head
      const headGeom = new THREE.BoxGeometry(3, 2.8, 3.2);
      const head = new THREE.Mesh(headGeom, kaijuMat);
      head.position.y = 8;
      head.castShadow = true;
      kaijuGroup.add(head);
      
      // Jaw
      const jawGeom = new THREE.BoxGeometry(2.5, 1, 3);
      const jaw = new THREE.Mesh(jawGeom, scaleMat);
      jaw.position.set(0, 6.8, 0.5);
      kaijuGroup.add(jaw);
      
      // Glowing eyes
      const eyeGeom = new THREE.SphereGeometry(0.4, 12, 12);
      const eyeMat = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 2
      });
      const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
      leftEye.position.set(-0.8, 8.3, 1.4);
      const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
      rightEye.position.set(0.8, 8.3, 1.4);
      kaijuGroup.add(leftEye, rightEye);
      
      // Horns
      for (let side = -1; side <= 1; side += 2) {
        const hornGeom = new THREE.ConeGeometry(0.3, 1.8, 6);
        const horn = new THREE.Mesh(hornGeom, scaleMat);
        horn.position.set(side * 1.2, 9.5, 0);
        horn.rotation.z = side * Math.PI / 6;
        kaijuGroup.add(horn);
      }
      
      // Massive arms
      for (let side = -1; side <= 1; side += 2) {
        const shoulderGeom = new THREE.SphereGeometry(1, 16, 16);
        const shoulder = new THREE.Mesh(shoulderGeom, kaijuMat);
        shoulder.position.set(side * 3, 6, 0);
        kaijuGroup.add(shoulder);
        
        const upperArmGeom = new THREE.CylinderGeometry(0.8, 0.9, 3, 12);
        const upperArm = new THREE.Mesh(upperArmGeom, kaijuMat);
        upperArm.position.set(side * 3.5, 4, 0);
        kaijuGroup.add(upperArm);
        
        const forearmGeom = new THREE.CylinderGeometry(0.9, 1.1, 2.5, 12);
        const forearm = new THREE.Mesh(forearmGeom, scaleMat);
        forearm.position.set(side * 4, 1.8, 0);
        kaijuGroup.add(forearm);
        
        // Claws
        for (let c = 0; c < 4; c++) {
          const clawGeom = new THREE.ConeGeometry(0.15, 1.2, 4);
          const claw = new THREE.Mesh(clawGeom, eyeMat);
          claw.position.set(side * 4.2 + (c - 1.5) * 0.25, 0.2, 0.5);
          claw.rotation.x = Math.PI / 3;
          kaijuGroup.add(claw);
        }
      }
      
      // Thick legs
      for (let side = -1; side <= 1; side += 2) {
        const thighGeom = new THREE.CylinderGeometry(1, 1.1, 3.5, 12);
        const thigh = new THREE.Mesh(thighGeom, kaijuMat);
        thigh.position.set(side * 1.5, 1.5, 0);
        kaijuGroup.add(thigh);
        
        const calfGeom = new THREE.CylinderGeometry(0.9, 1, 2.5, 12);
        const calf = new THREE.Mesh(calfGeom, scaleMat);
        calf.position.set(side * 1.5, -1.5, 0.3);
        kaijuGroup.add(calf);
        
        // Foot
        const footGeom = new THREE.BoxGeometry(1.2, 0.5, 2);
        const foot = new THREE.Mesh(footGeom, kaijuMat);
        foot.position.set(side * 1.5, -2.8, 0.8);
        kaijuGroup.add(foot);
      }
      
      // Massive tail
      for (let i = 0; i < 8; i++) {
        const size = 0.8 - (i * 0.08);
        const tailGeom = new THREE.CylinderGeometry(size, size * 0.85, 1.5, 8);
        const tail = new THREE.Mesh(tailGeom, i % 2 === 0 ? kaijuMat : scaleMat);
        tail.position.set(0, 3 - i * 0.3, -2 - i * 1.2);
        tail.rotation.x = Math.PI / 2 + (i * 0.15);
        kaijuGroup.add(tail);
      }
      
      kaijuGroup.position.set(12, 0, 0);
      kaijuGroup.scale.set(1.8, 1.8, 1.8);
      return kaijuGroup;
    }

    function setupPartInventory() {
      const inventory = document.getElementById('parts-inventory');
      partTypes.forEach(part => {
        const button = document.createElement('button');
        button.className = 'part-slot w-full p-3 rounded-lg text-left font-teko text-lg font-bold transition-all';
        button.style.cssText = `background: linear-gradient(135deg, rgba(0,180,216,0.1), rgba(0,119,182,0.1)); border: 2px solid rgba(0,180,216,0.3); color: #90e0ef;`;
        button.innerHTML = `
          <div class="flex items-center justify-between">
            <span>${part.emoji} ${part.name}</span>
            <span class="text-xs">H:${part.height}m</span>
          </div>
          <div class="text-xs opacity-75 mt-1">
            ‚ö°${part.power} üõ°Ô∏è${part.armor} üí®${part.speed}
          </div>
        `;
        button.addEventListener('click', () => {
          if (tempPart) buildScene.remove(tempPart);
          selectedPartType = part.id;
          tempPart = createPart3D(part.id);
          if (tempPart) {
            tempPart.position.set(currentX, currentHeight + 1, currentZ);
            buildScene.add(tempPart);
          }
          document.getElementById('weld-btn').disabled = false;
          document.querySelectorAll('.part-slot').forEach(btn => {
            btn.style.borderColor = 'rgba(0,180,216,0.3)';
          });
          button.style.borderColor = '#00b4d8';
        });
        inventory.appendChild(button);
      });
    }

    function setupBuildControls() {
      document.getElementById('move-up-btn').addEventListener('click', () => {
        if (tempPart) {
          currentHeight += 0.5;
          tempPart.position.y = currentHeight + 1;
          updatePositionDisplay();
        }
      });
      document.getElementById('move-down-btn').addEventListener('click', () => {
        if (tempPart && currentHeight > -2) {
          currentHeight -= 0.5;
          tempPart.position.y = currentHeight + 1;
          updatePositionDisplay();
        }
      });
      document.getElementById('move-left-btn').addEventListener('click', () => {
        if (tempPart) {
          currentX -= 0.5;
          tempPart.position.x = currentX;
          updatePositionDisplay();
        }
      });
      document.getElementById('move-right-btn').addEventListener('click', () => {
        if (tempPart) {
          currentX += 0.5;
          tempPart.position.x = currentX;
          updatePositionDisplay();
        }
      });
      document.getElementById('move-forward-btn').addEventListener('click', () => {
        if (tempPart) {
          currentZ -= 0.5;
          tempPart.position.z = currentZ;
          updatePositionDisplay();
        }
      });
      document.getElementById('move-back-btn').addEventListener('click', () => {
        if (tempPart) {
          currentZ += 0.5;
          tempPart.position.z = currentZ;
          updatePositionDisplay();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (currentMode !== 'build' || !tempPart) return;
        switch(e.key) {
          case 'ArrowUp':
            e.preventDefault();
            currentHeight += 0.5;
            tempPart.position.y = currentHeight + 1;
            updatePositionDisplay();
            break;
          case 'ArrowDown':
            e.preventDefault();
            if (currentHeight > -2) {
              currentHeight -= 0.5;
              tempPart.position.y = currentHeight + 1;
              updatePositionDisplay();
            }
            break;
          case 'ArrowLeft':
            e.preventDefault();
            currentX -= 0.5;
            tempPart.position.x = currentX;
            updatePositionDisplay();
            break;
          case 'ArrowRight':
            e.preventDefault();
            currentX += 0.5;
            tempPart.position.x = currentX;
            updatePositionDisplay();
            break;
          case 'w':
          case 'W':
            currentZ -= 0.5;
            tempPart.position.z = currentZ;
            updatePositionDisplay();
            break;
          case 's':
          case 'S':
            currentZ += 0.5;
            tempPart.position.z = currentZ;
            updatePositionDisplay();
            break;
          case ' ':
            e.preventDefault();
            document.getElementById('weld-btn').click();
            break;
        }
      });
      
      document.getElementById('weld-btn').addEventListener('click', () => {
        if (!tempPart) return;
        const canvas = buildRenderer.domElement;
        canvas.style.filter = 'brightness(2)';
        setTimeout(() => { canvas.style.filter = 'brightness(1)'; }, 100);
        weldedParts.push(tempPart);
        const stats = tempPart.userData.stats;
        if (stats) {
          jaegerStats.power += stats.power;
          jaegerStats.armor += stats.armor;
          jaegerStats.speed += stats.speed;
          updateStatsDisplay();
        }
        tempPart = null;
        selectedPartType = null;
        currentX = 0;
        currentZ = 0;
        document.getElementById('weld-btn').disabled = true;
        updatePositionDisplay();
      });
      
      document.getElementById('clear-jaeger-btn').addEventListener('click', () => {
        weldedParts.forEach(part => buildScene.remove(part));
        weldedParts = [];
        if (tempPart) {
          buildScene.remove(tempPart);
          tempPart = null;
        }
        currentHeight = 0;
        currentX = 0;
        currentZ = 0;
        jaegerStats = { power: 0, armor: 0, speed: 0 };
        updateStatsDisplay();
        updatePositionDisplay();
        document.getElementById('weld-btn').disabled = true;
      });
    }

    function setupModeToggle() {
      const buildBtn = document.getElementById('build-mode-btn');
      const combatBtn = document.getElementById('combat-mode-btn');
      const buildMode = document.getElementById('build-mode');
      const combatMode = document.getElementById('combat-mode');
      buildBtn.addEventListener('click', () => {
        currentMode = 'build';
        buildMode.classList.remove('hidden');
        buildMode.classList.add('flex');
        combatMode.classList.add('hidden');
        combatMode.classList.remove('flex');
      });
      combatBtn.addEventListener('click', () => {
        if (weldedParts.length === 0) {
          addBattleLog('Build a Jaeger first!', '#e63946');
          return;
        }
        currentMode = 'combat';
        buildMode.classList.add('hidden');
        buildMode.classList.remove('flex');
        combatMode.classList.remove('hidden');
        combatMode.classList.add('flex');
        startCombat();
      });
    }

    function startCombat() {
      if (playerJaeger) combatScene.remove(playerJaeger);
      if (enemyKaiju) combatScene.remove(enemyKaiju);
      playerJaeger = createJaegerFromParts();
      enemyKaiju = createKaiju();
      combatScene.add(playerJaeger);
      combatScene.add(enemyKaiju);
      playerHP = 100 + jaegerStats.armor;
      enemyHP = 150;
      combatInProgress = true;
      playerPosition = { x: -10, z: 0 };
      playerRotation = 0;
      cameraYaw = 0;
      cameraPitch = 0;
      playerJaeger.position.set(-10, 0, 0);
      playerJaeger.rotation.y = 0;
      enemyKaiju.position.set(12, 0, 0);
      keys = {};
      document.getElementById('player-hp').textContent = playerHP;
      document.getElementById('enemy-hp').textContent = enemyHP;
      updateHealthBars();
      battleLog = [];
      document.getElementById('battle-log').innerHTML = `
        <div>Neural handshake complete!</div>
        <div style="color: #ffc300;">Engaging Kaiju!</div>
        <div style="color: #90e0ef;">Use WASD to move, Q/E to rotate!</div>
      `;
      document.getElementById('battle-result').classList.add('hidden');
    }

    function setupCombatControls() {
      document.addEventListener('keydown', (e) => {
        if (currentMode !== 'combat' || !combatInProgress) return;
        keys[e.key.toLowerCase()] = true;
        if (e.key === '1') document.getElementById('attack-punch-btn').click();
        if (e.key === '2') document.getElementById('attack-plasma-btn').click();
        if (e.key === '3') document.getElementById('attack-sword-btn').click();
        if (e.key === ' ') {
          e.preventDefault();
          document.getElementById('attack-punch-btn').click();
        }
      });
      document.addEventListener('keyup', (e) => {
        keys[e.key.toLowerCase()] = false;
      });
      
      // Mouse click attacks
      document.addEventListener('mousedown', (e) => {
        if (currentMode !== 'combat' || !combatInProgress) return;
        if (document.pointerLockElement !== document.getElementById('combat-canvas')) return;
        
        if (e.button === 0) { // Left click - Sword swing
          playerAttack('sword', 25, 40, 8);
        } else if (e.button === 2) { // Right click - Plasma cannon
          e.preventDefault();
          playerAttack('plasma', 20, 35, 15);
        }
      });
      
      // Prevent context menu in combat
      document.getElementById('combat-canvas').addEventListener('contextmenu', (e) => {
        if (currentMode === 'combat') e.preventDefault();
      });
      
      document.getElementById('attack-punch-btn').addEventListener('click', () => {
        if (!combatInProgress) return;
        playerAttack('punch', 15, 25, 8);
      });
      document.getElementById('attack-plasma-btn').addEventListener('click', () => {
        if (!combatInProgress) return;
        playerAttack('plasma', 20, 35, 15);
      });
      document.getElementById('attack-sword-btn').addEventListener('click', () => {
        if (!combatInProgress) return;
        playerAttack('sword', 25, 40, 7);
      });
      document.getElementById('return-build-btn').addEventListener('click', () => {
        document.getElementById('build-mode-btn').click();
      });
    }
    
    function updatePlayerMovement() {
      if (!playerJaeger || !combatInProgress) return;
      const moveSpeed = 0.15 + (jaegerStats.speed * 0.002);
      let isMoving = false;
      
      // Rotate player based on camera yaw
      playerRotation = cameraYaw;
      
      // Move relative to camera direction
      if (keys['w']) {
        playerPosition.x += Math.sin(cameraYaw) * moveSpeed;
        playerPosition.z += Math.cos(cameraYaw) * moveSpeed;
        isMoving = true;
      }
      if (keys['s']) {
        playerPosition.x -= Math.sin(cameraYaw) * moveSpeed;
        playerPosition.z -= Math.cos(cameraYaw) * moveSpeed;
        isMoving = true;
      }
      if (keys['a']) {
        playerPosition.x -= Math.cos(cameraYaw) * moveSpeed;
        playerPosition.z += Math.sin(cameraYaw) * moveSpeed;
        isMoving = true;
      }
      if (keys['d']) {
        playerPosition.x += Math.cos(cameraYaw) * moveSpeed;
        playerPosition.z -= Math.sin(cameraYaw) * moveSpeed;
        isMoving = true;
      }
      
      playerPosition.x = Math.max(-20, Math.min(20, playerPosition.x));
      playerPosition.z = Math.max(-20, Math.min(20, playerPosition.z));
      playerJaeger.position.x = playerPosition.x;
      playerJaeger.position.z = playerPosition.z;
      playerJaeger.rotation.y = playerRotation;
      
      // Animate walking when moving
      if (isMoving && !playerJaeger.userData.isAttacking) {
        playerJaeger.userData.walkCycle += 0.15;
        animateWalking(playerJaeger);
      } else if (!playerJaeger.userData.isAttacking) {
        // Return to idle pose
        resetToIdlePose(playerJaeger);
      }
      
      // Update attack animations
      if (playerJaeger.userData.isAttacking) {
        updateAttackAnimation(playerJaeger);
      }
      
      // Third-person camera follows player
      const cameraDistance = 12;
      const cameraHeight = 7;
      const targetX = playerPosition.x - Math.sin(cameraYaw) * cameraDistance;
      const targetZ = playerPosition.z - Math.cos(cameraYaw) * cameraDistance;
      const targetY = playerPosition.y + cameraHeight + Math.sin(cameraPitch) * 5;
      
      // Smooth camera movement
      combatCamera.position.x += (targetX - combatCamera.position.x) * 0.15;
      combatCamera.position.y += (targetY - combatCamera.position.y) * 0.15;
      combatCamera.position.z += (targetZ - combatCamera.position.z) * 0.15;
      
      // Look at player position
      const lookAtX = playerPosition.x + Math.sin(cameraYaw) * 2;
      const lookAtZ = playerPosition.z + Math.cos(cameraYaw) * 2;
      combatCamera.lookAt(lookAtX, playerPosition.y + 4, lookAtZ);
    }
    
    function animateWalking(jaeger) {
      const cycle = jaeger.userData.walkCycle;
      
      // Leg swing
      if (jaeger.userData.legs) {
        jaeger.userData.legs.rotation.x = Math.sin(cycle) * 0.15;
      }
      
      // Hip sway
      if (jaeger.userData.lowerBody) {
        jaeger.userData.lowerBody.rotation.z = Math.sin(cycle) * 0.05;
      }
      
      // Upper body counter-rotation
      if (jaeger.userData.upperBody) {
        jaeger.userData.upperBody.rotation.z = -Math.sin(cycle) * 0.03;
        jaeger.userData.upperBody.rotation.y = Math.sin(cycle) * 0.08;
      }
      
      // Arm swing
      if (jaeger.userData.arms) {
        jaeger.userData.arms.rotation.x = Math.sin(cycle + Math.PI) * 0.12;
      }
      
      // Head stabilization (stays mostly level)
      if (jaeger.userData.head) {
        jaeger.userData.head.rotation.x = -Math.sin(cycle) * 0.02;
      }
      
      // Weapon sway
      if (jaeger.userData.weaponL) {
        jaeger.userData.weaponL.rotation.x = Math.sin(cycle + Math.PI) * 0.1;
      }
      if (jaeger.userData.weaponR) {
        jaeger.userData.weaponR.rotation.x = Math.sin(cycle) * 0.1;
      }
      
      // Vertical bobbing
      jaeger.position.y = Math.abs(Math.sin(cycle)) * 0.15;
    }
    
    function resetToIdlePose(jaeger) {
      const smoothing = 0.1;
      
      if (jaeger.userData.legs) {
        jaeger.userData.legs.rotation.x *= (1 - smoothing);
      }
      if (jaeger.userData.lowerBody) {
        jaeger.userData.lowerBody.rotation.z *= (1 - smoothing);
      }
      if (jaeger.userData.upperBody) {
        jaeger.userData.upperBody.rotation.z *= (1 - smoothing);
        jaeger.userData.upperBody.rotation.y *= (1 - smoothing);
      }
      if (jaeger.userData.arms) {
        jaeger.userData.arms.rotation.x *= (1 - smoothing);
      }
      if (jaeger.userData.head) {
        jaeger.userData.head.rotation.x *= (1 - smoothing);
      }
      if (jaeger.userData.weaponL) {
        jaeger.userData.weaponL.rotation.x *= (1 - smoothing);
      }
      if (jaeger.userData.weaponR) {
        jaeger.userData.weaponR.rotation.x *= (1 - smoothing);
      }
      jaeger.position.y *= (1 - smoothing);
    }
    
    function playerAttack(type, minDmg, maxDmg, range) {
      if (playerJaeger.userData.isAttacking) return; // Prevent attack spam
      
      const damage = Math.floor(Math.random() * (maxDmg - minDmg + 1)) + minDmg;
      const bonusDamage = Math.floor(jaegerStats.power * 0.3);
      const totalDamage = damage + bonusDamage;
      const distance = Math.sqrt(
        Math.pow(playerPosition.x - 8, 2) + 
        Math.pow(playerPosition.z - 0, 2)
      );
      if (distance > range) {
        addBattleLog(`‚ùå Out of range! Get closer! (${distance.toFixed(1)}m / ${range}m)`, '#e63946');
        return;
      }
      
      // Start attack animation
      playerJaeger.userData.isAttacking = true;
      playerJaeger.userData.attackFrame = 0;
      playerJaeger.userData.currentAttack = type;
      
      enemyHP = Math.max(0, enemyHP - totalDamage);
      
      const attackNames = {
        punch: 'ROCKET PUNCH',
        plasma: 'PLASMA CANNON',
        sword: 'EXCALIBUR STAB'
      };
      addBattleLog(`‚ö° ${attackNames[type]}: ${totalDamage} damage!`, '#00b4d8');
      updateHealthBars();
      
      // End attack after animation completes
      setTimeout(() => {
        if (playerJaeger) {
          playerJaeger.userData.isAttacking = false;
          playerJaeger.userData.currentAttack = null;
        }
      }, type === 'sword' ? 800 : 500);
      
      if (enemyHP <= 0) {
        setTimeout(() => endCombat(true), 1000);
      }
    }
    
    function updateAttackAnimation(jaeger) {
      jaeger.userData.attackFrame += 1;
      const frame = jaeger.userData.attackFrame;
      const attackType = jaeger.userData.currentAttack;
      
      if (attackType === 'punch') {
        // Rocket punch - left arm extends forward
        if (frame < 10) {
          // Wind up
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.y = -0.3 * (frame / 10);
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.x = -0.5 * (frame / 10);
          }
        } else if (frame < 20) {
          // Strike!
          const strikeProgress = (frame - 10) / 10;
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.y = -0.3 + (0.5 * strikeProgress);
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.x = -0.5 + (0.8 * strikeProgress);
          }
          if (jaeger.userData.weaponL) {
            jaeger.userData.weaponL.position.z = -1.5 * strikeProgress;
          }
        } else {
          // Return
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.y *= 0.85;
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.x *= 0.85;
          }
          if (jaeger.userData.weaponL) {
            jaeger.userData.weaponL.position.z *= 0.85;
          }
        }
      } else if (attackType === 'plasma') {
        // Plasma cannon - aim and fire
        if (frame < 8) {
          // Raise cannon
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.x = -0.2 * (frame / 8);
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.y = 0.3 * (frame / 8);
          }
          if (jaeger.userData.weaponL) {
            jaeger.userData.weaponL.rotation.x = -0.4 * (frame / 8);
          }
        } else if (frame < 15) {
          // Fire! (recoil)
          const recoilProgress = (frame - 8) / 7;
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.x = -0.2 + (0.15 * Math.sin(recoilProgress * Math.PI));
          }
          if (jaeger.userData.weaponL) {
            jaeger.userData.weaponL.position.z = -0.5 * Math.sin(recoilProgress * Math.PI);
          }
        } else {
          // Return
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.x *= 0.9;
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.y *= 0.9;
          }
          if (jaeger.userData.weaponL) {
            jaeger.userData.weaponL.rotation.x *= 0.9;
            jaeger.userData.weaponL.position.z *= 0.9;
          }
        }
      } else if (attackType === 'sword') {
        // Excalibur energy sword stab - dramatic overhead strike
        if (frame < 15) {
          // Wind up - raise sword overhead
          const windupProgress = frame / 15;
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.y = 0.4 * windupProgress;
            jaeger.userData.upperBody.rotation.x = -0.3 * windupProgress;
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.x = -1.2 * windupProgress; // Arms up
            jaeger.userData.arms.rotation.z = 0.3 * windupProgress;
          }
          if (jaeger.userData.weaponR) {
            jaeger.userData.weaponR.rotation.x = -1.5 * windupProgress; // Sword raised high
            jaeger.userData.weaponR.position.y = 1.5 * windupProgress;
          }
          if (jaeger.userData.head) {
            jaeger.userData.head.rotation.x = -0.2 * windupProgress; // Look up
          }
        } else if (frame < 25) {
          // STAB! - Lightning fast downward thrust
          const stabProgress = (frame - 15) / 10;
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.y = 0.4 - (0.7 * stabProgress);
            jaeger.userData.upperBody.rotation.x = -0.3 + (0.6 * stabProgress);
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.x = -1.2 + (1.5 * stabProgress);
            jaeger.userData.arms.rotation.z = 0.3 - (0.3 * stabProgress);
          }
          if (jaeger.userData.weaponR) {
            jaeger.userData.weaponR.rotation.x = -1.5 + (2.0 * stabProgress);
            jaeger.userData.weaponR.position.y = 1.5 - (2.5 * stabProgress);
            jaeger.userData.weaponR.position.z = -2.0 * stabProgress; // Thrust forward
          }
          if (jaeger.userData.lowerBody) {
            jaeger.userData.lowerBody.rotation.x = 0.15 * stabProgress; // Lean into stab
          }
          if (jaeger.userData.head) {
            jaeger.userData.head.rotation.x = -0.2 + (0.3 * stabProgress); // Look down at target
          }
          // Lunge forward
          if (frame === 18) {
            jaeger.position.x += Math.sin(playerRotation) * 2;
            jaeger.position.z += Math.cos(playerRotation) * 2;
          }
        } else if (frame < 35) {
          // Hold the stab briefly (sword penetrating)
          const holdProgress = (frame - 25) / 10;
          if (jaeger.userData.weaponR) {
            // Slight twist of the blade
            jaeger.userData.weaponR.rotation.y = 0.2 * Math.sin(holdProgress * Math.PI * 2);
          }
        } else {
          // Withdraw - pull back to neutral
          const returnProgress = Math.min(1, (frame - 35) / 15);
          if (jaeger.userData.upperBody) {
            jaeger.userData.upperBody.rotation.y *= (1 - returnProgress * 0.15);
            jaeger.userData.upperBody.rotation.x *= (1 - returnProgress * 0.15);
          }
          if (jaeger.userData.arms) {
            jaeger.userData.arms.rotation.x *= (1 - returnProgress * 0.15);
            jaeger.userData.arms.rotation.z *= (1 - returnProgress * 0.15);
          }
          if (jaeger.userData.weaponR) {
            jaeger.userData.weaponR.rotation.x *= (1 - returnProgress * 0.15);
            jaeger.userData.weaponR.rotation.y *= (1 - returnProgress * 0.15);
            jaeger.userData.weaponR.position.y *= (1 - returnProgress * 0.15);
            jaeger.userData.weaponR.position.z *= (1 - returnProgress * 0.15);
          }
          if (jaeger.userData.lowerBody) {
            jaeger.userData.lowerBody.rotation.x *= (1 - returnProgress * 0.15);
          }
          if (jaeger.userData.head) {
            jaeger.userData.head.rotation.x *= (1 - returnProgress * 0.15);
          }
          // Return to original position
          const dx = jaeger.position.x - playerPosition.x;
          const dz = jaeger.position.z - playerPosition.z;
          jaeger.position.x -= dx * returnProgress * 0.15;
          jaeger.position.z -= dz * returnProgress * 0.15;
        }
      }
    }
    
    function updateEnemyAI() {
      if (!enemyKaiju || !combatInProgress || enemyHP <= 0) return;
      const dx = playerPosition.x - 12;
      const dz = playerPosition.z - 0;
      const distance = Math.sqrt(dx * dx + dz * dz);
      if (distance > 10) {
        enemyKaiju.position.x += dx * 0.01;
        enemyKaiju.position.z += dz * 0.01;
      }
      const angle = Math.atan2(dx, dz);
      enemyKaiju.rotation.y = angle;
      if (Math.random() < 0.01 && distance < 15) {
        enemyAttackActive();
      }
    }
    
    function enemyAttackActive() {
      const attacks = [
        { name: 'CLAW STRIKE', min: 15, max: 25 },
        { name: 'TAIL WHIP', min: 20, max: 30 },
        { name: 'ACID SPIT', min: 25, max: 35 }
      ];
      const attack = attacks[Math.floor(Math.random() * attacks.length)];
      let damage = Math.floor(Math.random() * (attack.max - attack.min + 1)) + attack.min;
      const dx = playerPosition.x - enemyKaiju.position.x;
      const dz = playerPosition.z - enemyKaiju.position.z;
      const distance = Math.sqrt(dx * dx + dz * dz);
      if (distance > 12) {
        damage = Math.floor(damage * 0.5);
      }
      const damageReduction = Math.floor(jaegerStats.armor * 0.2);
      damage = Math.max(5, damage - damageReduction);
      playerHP = Math.max(0, playerHP - damage);
      if (enemyKaiju) {
        const originalX = enemyKaiju.position.x;
        const originalZ = enemyKaiju.position.z;
        enemyKaiju.position.x -= dx * 0.3;
        enemyKaiju.position.z -= dz * 0.3;
        setTimeout(() => { 
          if (enemyKaiju) {
            enemyKaiju.position.x = originalX;
            enemyKaiju.position.z = originalZ;
          }
        }, 300);
      }
      addBattleLog(`üíÄ Kaiju ${attack.name}: ${damage} damage!`, '#e63946');
      updateHealthBars();
      if (playerHP <= 0) {
        setTimeout(() => endCombat(false), 1000);
      }
    }

    function updateHealthBars() {
      const playerBar = document.getElementById('player-health-bar');
      const enemyBar = document.getElementById('enemy-health-bar');
      const maxPlayerHP = 100 + jaegerStats.armor;
      playerBar.style.width = `${(playerHP / maxPlayerHP) * 100}%`;
      enemyBar.style.width = `${(enemyHP / 150) * 100}%`;
      document.getElementById('player-hp').textContent = playerHP;
      document.getElementById('enemy-hp').textContent = enemyHP;
    }

    function addBattleLog(message, color = '#90e0ef') {
      const log = document.getElementById('battle-log');
      const entry = document.createElement('div');
      entry.textContent = message;
      entry.style.color = color;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }

    function endCombat(playerWon) {
      combatInProgress = false;
      keys = {};
      const resultScreen = document.getElementById('battle-result');
      const resultTitle = document.getElementById('result-title');
      const resultMessage = document.getElementById('result-message');
      if (playerWon) {
        resultTitle.textContent = '‚ö° VICTORY!';
        resultTitle.style.color = '#00b4d8';
        resultMessage.textContent = 'The Kaiju has been defeated! The Breach is sealed!';
        addBattleLog('üèÜ VICTORY! Kaiju eliminated!', '#ffc300');
      } else {
        resultTitle.textContent = 'üíÄ DEFEATED';
        resultTitle.style.color = '#e63946';
        resultMessage.textContent = 'Your Jaeger has fallen. Rebuild and try again!';
        addBattleLog('üíÄ DEFEAT! Jaeger destroyed!', '#e63946');
      }
      resultScreen.classList.remove('hidden');
    }

    function updateStatsDisplay() {
      document.getElementById('stat-power').textContent = jaegerStats.power;
      document.getElementById('stat-armor').textContent = jaegerStats.armor;
      document.getElementById('stat-speed').textContent = jaegerStats.speed;
      document.getElementById('stat-total').textContent = jaegerStats.power + jaegerStats.armor + jaegerStats.speed;
    }

    function updatePositionDisplay() {
      document.getElementById('current-height').textContent = currentHeight.toFixed(1);
      document.getElementById('current-x').textContent = currentX.toFixed(1);
      document.getElementById('current-z').textContent = currentZ.toFixed(1);
    }

    function animateBuild() {
      requestAnimationFrame(animateBuild);
      if (tempPart) {
        tempPart.rotation.y += 0.01;
      }
      weldedParts.forEach(part => {
        part.rotation.y += 0.002;
      });
      buildRenderer.render(buildScene, buildCamera);
    }

    function animateCombat() {
      requestAnimationFrame(animateCombat);
      if (combatInProgress) {
        updatePlayerMovement();
        updateEnemyAI();
      }
      if (enemyKaiju && combatInProgress) {
        enemyKaiju.position.y = Math.sin(Date.now() * 0.002) * 0.2;
      }
      combatRenderer.render(combatScene, combatCamera);
    }

    async function onConfigChange(cfg) {
      const customFont = cfg.font_family || defaultConfig.font_family;
      const baseSize = cfg.font_size || defaultConfig.font_size;
      const title = document.getElementById('game-title');
      if (title) {
        title.textContent = cfg.game_title || defaultConfig.game_title;
        title.style.fontFamily = `${customFont}, 'Orbitron', sans-serif`;
        title.style.fontSize = `${baseSize * 1.875}px`;
        title.style.color = cfg.primary_color || defaultConfig.primary_color;
      }
      const instructions = document.getElementById('instruction-text');
      if (instructions) {
        instructions.textContent = cfg.instruction_text || defaultConfig.instruction_text;
        instructions.style.color = cfg.secondary_color || defaultConfig.secondary_color;
        instructions.style.fontSize = `${baseSize}px`;
      }
      const buildLabel = document.getElementById('build-mode-label');
      if (buildLabel) {
        buildLabel.textContent = cfg.build_mode_label || defaultConfig.build_mode_label;
      }
      const combatLabel = document.getElementById('combat-mode-label');
      if (combatLabel) {
        combatLabel.textContent = cfg.combat_mode_label || defaultConfig.combat_mode_label;
      }
      const app = document.getElementById('app');
      if (app) {
        app.style.background = `linear-gradient(180deg, ${cfg.background_color || defaultConfig.background_color} 0%, #001d3d 50%, #003566 100%)`;
      }
    }

    function mapToCapabilities(cfg) {
      return {
        recolorables: [
          {
            get: () => cfg.background_color || defaultConfig.background_color,
            set: (value) => {
              config.background_color = value;
              if (window.elementSdk) window.elementSdk.setConfig({ background_color: value });
            }
          },
          {
            get: () => cfg.primary_color || defaultConfig.primary_color,
            set: (value) => {
              config.primary_color = value;
              if (window.elementSdk) window.elementSdk.setConfig({ primary_color: value });
            }
          },
          {
            get: () => cfg.secondary_color || defaultConfig.secondary_color,
            set: (value) => {
              config.secondary_color = value;
              if (window.elementSdk) window.elementSdk.setConfig({ secondary_color: value });
            }
          },
          {
            get: () => cfg.enemy_color || defaultConfig.enemy_color,
            set: (value) => {
              config.enemy_color = value;
              if (window.elementSdk) window.elementSdk.setConfig({ enemy_color: value });
            }
          },
          {
            get: () => cfg.accent_color || defaultConfig.accent_color,
            set: (value) => {
              config.accent_color = value;
              if (window.elementSdk) window.elementSdk.setConfig({ accent_color: value });
            }
          }
        ],
        borderables: [],
        fontEditable: {
          get: () => cfg.font_family || defaultConfig.font_family,
          set: (value) => {
            config.font_family = value;
            if (window.elementSdk) window.elementSdk.setConfig({ font_family: value });
          }
        },
        fontSizeable: {
          get: () => cfg.font_size || defaultConfig.font_size,
          set: (value) => {
            config.font_size = value;
            if (window.elementSdk) window.elementSdk.setConfig({ font_size: value });
          }
        }
      };
    }

    function mapToEditPanelValues(cfg) {
      return new Map([
        ['game_title', cfg.game_title || defaultConfig.game_title],
        ['instruction_text', cfg.instruction_text || defaultConfig.instruction_text],
        ['build_mode_label', cfg.build_mode_label || defaultConfig.build_mode_label],
        ['combat_mode_label', cfg.combat_mode_label || defaultConfig.combat_mode_label]
      ]);
    }

    if (window.elementSdk) {
      window.elementSdk.init({
        defaultConfig,
        onConfigChange,
        mapToCapabilities,
        mapToEditPanelValues
      });
      config = window.elementSdk.config || { ...defaultConfig };
    }

    window.addEventListener('resize', () => {
      if (buildRenderer && buildCamera) {
        const buildContainer = document.getElementById('build-canvas');
        buildCamera.aspect = buildContainer.clientWidth / buildContainer.clientHeight;
        buildCamera.updateProjectionMatrix();
        buildRenderer.setSize(buildContainer.clientWidth, buildContainer.clientHeight);
      }
      if (combatRenderer && combatCamera) {
        const combatContainer = document.getElementById('combat-canvas');
        combatCamera.aspect = combatContainer.clientWidth / combatContainer.clientHeight;
        combatCamera.updateProjectionMatrix();
        combatRenderer.setSize(combatContainer.clientWidth, combatContainer.clientHeight);
      }
    });

    window.addEventListener('DOMContentLoaded', () => {
      initBuildMode();
      initCombatMode();
      setupPartInventory();
      setupBuildControls();
      setupModeToggle();
      setupCombatControls();
      updateStatsDisplay();
      updatePositionDisplay();
      onConfigChange(config);
      document.getElementById('weld-btn').disabled = true;
    });
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9c644f68f6508c8f',t:'MTc2OTgxMTE0MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
